% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normalizeFilterReadCounts.R
\name{normalizeFilterReadCounts}
\alias{normalizeFilterReadCounts}
\title{Normalize and Filter Read Counts}
\usage{
normalizeFilterReadCounts(
  sample_mat,
  conditions,
  loc1,
  loc2,
  nrow_output,
  ncol_output,
  filter = F,
  underscored_positions_col = underscored_positions_col,
  underscored_positions_row,
  output_type = "corrected_counts",
  norm_factor_type = "TMMwsp",
  filter_type = "ave_ab",
  estimate_dispersion = F,
  norm_offsets = F,
  skip_mats = F
)
}
\arguments{
\item{sample_mat}{A matrix of raw read counts where rows represent genes and columns represent samples.}

\item{conditions}{A factor or vector that specifies the condition/group for each column in `sample_mat`.}

\item{loc1}{A vector indicating the first location identifier for each row in `sample_mat`.}

\item{loc2}{A vector indicating the second location identifier for each row in `sample_mat`.}

\item{nrow_output}{The desired number of rows in the output matrices.}

\item{ncol_output}{The desired number of columns in the output matrices.}

\item{filter}{Logical; if TRUE, performs filtering based on median counts per million.}

\item{underscored_positions_col}{Column names for the output matrices, typically indicating positions with underscores.}

\item{underscored_positions_row}{Row names for the output matrices, typically indicating positions with underscores.}

\item{output_type}{A character string specifying the type of output: "dgel" for DGEList object, "corrected_counts" for normalized counts,
"cpm" for counts per million, or "logcpm" for log-transformed counts per million. Defaults to "corrected_counts".}

\item{norm_factor_type}{A character string specifying the type of normalization factor to use: "TMMwsp" for TMM with singleton pairing,
"TMM" for TMM normalization, or "DESeq2" for DESeq2 normalization, or "TRC" for total read correction. Defaults to "TMMwsp", which works well for zero inflated data.
"NC" for normalizing by the number of nonzero counts.}

\item{filter_type}{A character string specifying the type of filtering to use: "ave_ab" for average log counts per million, "mean_loc_sum" for mean of the sum of counts per location,
or "diff" for the difference between the sum of counts in one condition versus all other conditions. Defaults to "ave_ab".}

\item{estimate_dispersion}{Logical; if TRUE, estimates dispersion using edgeR's `estimateDisp` function.}

\item{norm_offsets}{Logical; if TRUE, calculates normalization offsets using csaw's `normOffsets` function.}

\item{skip_mats}{Logical; if TRUE, skips the creation of matrices and returns the raw data table with indices.}
}
\value{
Depending on the `output_type` and `filter` parameters, this function can return a DGEList object,
a list of matrices with sum and variance for each condition, or a data table with normalized (filtered) counts.
For "dgel" output type, returns a DGEList object. For "corrected_counts", "cpm", or "logcpm" with `filter=FALSE`,
returns a list containing matrices of sum and variance for each condition, along with the conditions vector.
If `filter=TRUE`, returns a list containing matrices of sum and variance for filtered data, conditions vector,
and a data table linking locations to indices.
}
\description{
This function normalizes read counts from 2D basepairC data, optionally filters the data,
and returns various outputs based on the specified output type. It supports returning
raw DGEList objects, normalized counts, counts per million (CPM), and log-transformed CPM.
It can also split the normalized counts back into matrices for multiple conditions.
}
\examples{
# Assuming `sample_mat`, `conditions`, `loc1`, `loc2` are defined:
result <- normalizeFilterReadCounts(sample_mat, conditions, loc1, loc2, 100, 5)
# To get normalized counts without filtering:
normalized_counts <- normalizeFilterReadCounts(sample_mat, conditions, loc1, loc2, 100, 5, output_type = "corrected_counts")

}
